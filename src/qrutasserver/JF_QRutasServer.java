/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package qrutasserver;

import com.google.gson.Gson;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
import java.util.TreeMap;
import java.util.concurrent.TimeUnit;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

/**
 *
 * @author NA002456
 */
public class JF_QRutasServer extends javax.swing.JFrame {

    private Map<Integer, String> rutas_names;
    private String s_servidor;
    private int q_periodo;
    private ArrayList<Ruta> al_rutas;
    private ArrayList<Logfile> al_logfiles;
    private int delay_subido;
    private int delay_importado;
    private int delay_procesado;
    private Gson gson = new Gson();
    private QS_Cliente_Telegram tcliente;

    /**
     * Creates new form JF_QRutasServer
     */
    public JF_QRutasServer() {
        initComponents();

        s_servidor = "127.0.0.1";
//        s_servidor = "10.116.243.234";   
        q_periodo = 60000;
        delay_subido = 30;
        delay_importado = 60;
        delay_procesado = 30;
        rutas_names = carga_lista_rutas();
        al_rutas = new ArrayList();
        al_logfiles = new ArrayList();
        tcliente = new QS_Cliente_Telegram();
        System.out.println(rutas_names);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jB_run = new javax.swing.JButton();
        jB_status = new javax.swing.JButton();
        jCB_loadvariables = new javax.swing.JCheckBox();
        jB_save = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Qrutas Server 1.7");

        jB_run.setText("Run");
        jB_run.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jB_runActionPerformed(evt);
            }
        });

        jB_status.setText("Status");
        jB_status.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jB_statusActionPerformed(evt);
            }
        });

        jCB_loadvariables.setSelected(true);
        jCB_loadvariables.setText("Load variables");

        jB_save.setText("Save");
        jB_save.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jB_saveActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jB_run, javax.swing.GroupLayout.PREFERRED_SIZE, 63, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(16, 16, 16)
                        .addComponent(jCB_loadvariables))
                    .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                        .addComponent(jB_save, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jB_status, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap(216, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCB_loadvariables)
                    .addComponent(jB_run))
                .addGap(18, 18, 18)
                .addComponent(jB_status)
                .addGap(18, 18, 18)
                .addComponent(jB_save)
                .addContainerGap(184, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jB_runActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jB_runActionPerformed
        jB_run.setEnabled(false);

        if (jCB_loadvariables.isSelected()) {
            al_rutas = (ArrayList<Ruta>) jsonReadFromFile("al_rutas.txt", 0);
            al_logfiles = (ArrayList<Logfile>) jsonReadFromFile("al_logfiles.txt", 1);
        } else {
            al_rutas = new ArrayList();
            for (int ruta_name_id : rutas_names.keySet()) {
                al_rutas.add(new Ruta(ruta_name_id));
            }
            al_logfiles = new ArrayList();
        }
        System.out.println("Variables loaded" + "");

        TT_QRutasServer tt_Alarmas = new TT_QRutasServer();
        Timer t_Alarmas = new Timer();
        t_Alarmas.scheduleAtFixedRate(tt_Alarmas, 0, q_periodo);
    }//GEN-LAST:event_jB_runActionPerformed

    private void jB_statusActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jB_statusActionPerformed
        System.out.println("Rutas:");
        for (Ruta ruta : al_rutas) {
            System.out.println(ruta.ruta_id + " - " + ruta.drives);
        }
        System.out.println("Logs:");
        for (Logfile logfile : al_logfiles) {
            System.out.println(logfile.logname + " - xs (" + logfile.isxsubir + " " + TimeUnit.MINUTES.convert((new Date().getTime() - (logfile.fechaxsubir == null ? new Date().getTime() : logfile.fechaxsubir.getTime())), TimeUnit.MILLISECONDS) + " " + logfile.vecesxsubir
                    + ") - su (" + logfile.issubido + " " + TimeUnit.MINUTES.convert((new Date().getTime() - (logfile.fechasubido == null ? new Date().getTime() : logfile.fechasubido.getTime())), TimeUnit.MILLISECONDS) + " " + logfile.vecessubido
                    + ") - im (" + logfile.isimportado + " " + TimeUnit.MINUTES.convert((new Date().getTime() - (logfile.fechaimportado == null ? new Date().getTime() : logfile.fechaimportado.getTime())), TimeUnit.MILLISECONDS) + " " + logfile.vecesimportado
                    + ") - pr (" + logfile.isprocesado + " " + TimeUnit.MINUTES.convert((new Date().getTime() - (logfile.fechaprocesado == null ? new Date().getTime() : logfile.fechaprocesado.getTime())), TimeUnit.MILLISECONDS) + " " + logfile.vecesprocesado + ")");
        }
    }//GEN-LAST:event_jB_statusActionPerformed

    private void jB_saveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jB_saveActionPerformed
        if (!jB_run.isEnabled())
            save_variables();
    }//GEN-LAST:event_jB_saveActionPerformed

    class TT_QRutasServer extends TimerTask {

        public TT_QRutasServer() {
        }

        @Override
        public void run() {
            System.out.println("Inicio corrida en: " + new Date());
            load_sql_logs();
            move_uploaded_logs();
            move_imported_logs();
            review_processed_logs();
            check_delayed_files();
            check_rutas_finished();
            System.out.println("Finaliza corrida en: " + new Date());
        }
    }

    private void save_variables() {
        boolean is_not_first = false;
        for (Ruta ruta : al_rutas) {
            jsonWriteToFile(gson.toJson(ruta), "al_rutas.txt", is_not_first);
            is_not_first = true;
        }
        is_not_first = false;
        if (!al_logfiles.isEmpty()) {
            for (Logfile logfile : al_logfiles) {
                jsonWriteToFile(gson.toJson(logfile), "al_logfiles.txt", is_not_first);
                is_not_first = true;
            }
        } else {
            jsonWriteToFile("", "al_logfiles.txt", is_not_first);
        }

        System.out.println("variables guardadas");
    }

    private void jsonWriteToFile(String jsonData, String f_file, boolean f_is_not_first) {
        File jsonFile = new File(f_file);
        if (!jsonFile.exists()) {
            System.out.println("archivo " + f_file + " no existe: ");
            return;
        }
        try {
            FileWriter jsonWriter = new FileWriter(jsonFile.getAbsoluteFile(), f_is_not_first);
            BufferedWriter bufferWriter = new BufferedWriter(jsonWriter);
            bufferWriter.write((f_is_not_first ? "\n" : "") + jsonData);
            bufferWriter.close();
        } catch (IOException e) {
            System.out.println("Hmm.. Got an error while saving " + f_file + " data to file " + e.toString());
        }
    }

    public ArrayList jsonReadFromFile(String f_file, int obj_type) {
        ArrayList f_lista = new ArrayList();
        File jsonFile = new File(f_file);
        if (!jsonFile.exists()) {
            System.out.println("File " + f_file + " doesn't exist");
            return f_lista;
        }
        try {
            BufferedReader task_file_io = new BufferedReader(new FileReader(jsonFile));
            String task_file_line = "";
            while ((task_file_line = task_file_io.readLine()) != null) {
                switch (obj_type) {
                    case 0:
                        f_lista.add(gson.fromJson(task_file_line, Ruta.class));
                        break;
                    case 1:
                        f_lista.add(gson.fromJson(task_file_line, Logfile.class));
                        break;
                }
            }
        } catch (IOException ex) {
            System.out.println(ex.getMessage());
        }
        return f_lista;
    }

    private void load_sql_logs() {
        Connection con_uio = null;
        PreparedStatement pst_uio = null;
        ResultSet rs_db_uio = null;
        String url_uio = "jdbc:mysql://" + s_servidor + ":3306/";
        String user = "root";
        String password = "enero2012";
        String db_query = "SELECT * FROM qrutas.logsxsubir";
        ArrayList<Integer> logsxborrar = new ArrayList();

        try {
            con_uio = DriverManager.getConnection(url_uio, user, password);
            pst_uio = con_uio.prepareStatement(db_query);
            rs_db_uio = pst_uio.executeQuery();
            while (rs_db_uio.next()) {
                String log_name_corto = rs_db_uio.getString("log");
                System.out.println("Agregando log xsubir:" + log_name_corto);
                int log_idruta = rs_db_uio.getInt("id_ruta");
                int log_id = rs_db_uio.getInt("id");
                logsxborrar.add(log_id);
                int al_ruta_index = al_rutas.indexOf(new Ruta(log_idruta));
                String dia_log = log_name_corto.substring(0, 4);

                if (al_rutas.get(al_ruta_index).drives.get(dia_log) == null) {
                    al_rutas.get(al_ruta_index).drives.put(dia_log, new ArrayList());
                }
                if (al_logfiles.indexOf(new Logfile(log_name_corto)) == -1) {
                    al_logfiles.add(new Logfile(log_name_corto));
                    al_rutas.get(al_ruta_index).drives.get(dia_log).add(log_name_corto);
                } else {
                    Logfile logfile = al_logfiles.get(al_logfiles.indexOf(new Logfile(log_name_corto)));
                    logfile.vecesxsubir++;
                    System.out.println(log_name_corto + " ya esta xsubir!!!");
                }

            }
            for (int logxborrar : logsxborrar) {
                db_query = "DELETE FROM qrutas.logsxsubir WHERE id = " + logxborrar;
                pst_uio = con_uio.prepareStatement(db_query);
                pst_uio.execute();
            }
        } catch (SQLException ex) {
            System.out.println(ex.getMessage());
            ex.printStackTrace();
        } finally {
            try {
                if (rs_db_uio != null) {
                    rs_db_uio.close();
                }
                if (pst_uio != null) {
                    pst_uio.close();
                }
                if (con_uio != null) {
                    con_uio.close();
                }
            } catch (SQLException ex) {
                System.out.println(ex.getMessage());
                ex.printStackTrace();
            }
        }
    }

    private void move_uploaded_logs() {
        File folder;
        File[] listOfFiles;
        folder = new File("ftp/");
        listOfFiles = folder.listFiles();

        for (File file : listOfFiles) {
            if (file.isFile()) {
                String log_name_largo = file.getName();
                System.out.println(log_name_largo + " " + new Date(file.lastModified()) + " " + TimeUnit.MINUTES.convert((new Date().getTime() - file.lastModified()), TimeUnit.MILLISECONDS));
                if (TimeUnit.MINUTES.convert((new Date().getTime() - file.lastModified()), TimeUnit.MILLISECONDS) > 2) {
                    if (log_name_largo.contains("William") || log_name_largo.contains("Diego") || log_name_largo.contains("NA002456")) {
                        System.out.println("Moviendo log subido:" + log_name_largo);
                        ArrayList<String> logname_parsed = new ArrayList(Arrays.asList((log_name_largo.trim()).split("_")));
                        int log_ruta_id = Integer.parseInt(logname_parsed.get(0).trim());
                        String f_ruta = rutas_names.get(log_ruta_id);
                        String log_name_corto = logname_parsed.get(2).trim();

                        if (al_logfiles.indexOf(new Logfile(log_name_corto)) != -1) {
                            Logfile logfile = al_logfiles.get(al_logfiles.indexOf(new Logfile(log_name_corto)));
                            if (!logfile.issubido) {
                                logfile.issubido = true;
                                logfile.fechasubido = new Date();
                                logfile.vecessubido = 1;

                                try {
                                    Path temp = Files.move(Paths.get("ftp/" + log_name_largo), Paths.get("rutas/" + f_ruta + "/logs/" + log_name_largo));
                                } catch (IOException ex) {
                                    System.out.println("Error moviendo archivo subido: " + ex.getMessage());
                                }

                            } else {
                                logfile.vecessubido++;
                                System.out.println(log_name_corto + " ya fue subido!!!");
                            }
                        } else {
                            System.out.println(log_name_corto + " no esta en lista de logfiles!!!");
                        }
                    }
                }
            }
        }
    }

    private void move_imported_logs() {
        File folder;
        File[] listOfRutasFolders;
        folder = new File("rutas/");
        listOfRutasFolders = folder.listFiles();

        for (File file : listOfRutasFolders) {
            File import_folder;
            File[] listOfImportedLogs;
            import_folder = new File(file.getPath() + "/logs_Imported/");
            listOfImportedLogs = import_folder.listFiles();
            for (File file2 : listOfImportedLogs) {
                if (file2.isFile()) {
                    String log_name_largo = file2.getName();
                    System.out.println(log_name_largo + " " + new Date(file2.lastModified()) + " " + TimeUnit.MINUTES.convert((new Date().getTime() - file2.lastModified()), TimeUnit.MILLISECONDS));
                    if (TimeUnit.MINUTES.convert((new Date().getTime() - file2.lastModified()), TimeUnit.MILLISECONDS) > 2) {
                        System.out.println("Moviendo log importado:" + log_name_largo);
                        ArrayList<String> logname_parsed = new ArrayList(Arrays.asList((log_name_largo.trim()).split("_")));
                        String log_name_corto = logname_parsed.get(2).trim();

                        if (al_logfiles.indexOf(new Logfile(log_name_corto)) != -1) {
                            Logfile logfile = al_logfiles.get(al_logfiles.indexOf(new Logfile(log_name_corto)));
                            if (!logfile.isimportado) {
                                if (logfile.issubido) {
                                    logfile.isimportado = true;
                                    logfile.fechaimportado = new Date();
                                    logfile.vecesimportado = 1;

                                    try {
                                        Path temp = Files.move(Paths.get(file.getPath() + "/logs_Imported/" + log_name_largo), Paths.get(file.getPath() + "/logs_Finished/" + log_name_largo));
                                    } catch (IOException ex) {
                                        System.out.println("Error moviendo archivo importado: " + ex.getMessage());
                                    }

                                } else {
                                    System.out.println(log_name_corto + " importado no esta subido!!!");
                                }
                            } else {
                                logfile.vecesimportado++;
                                System.out.println(log_name_corto + " ya esta importado!!!");
                            }
                        } else {
                            System.out.println(log_name_corto + " no esta en lista de logfiles!!!");
                        }
                    }
                }
            }
        }
    }

    private void review_processed_logs() {
        File folder;
        File[] listOfRutasFolders;
        folder = new File("rutas/");
        listOfRutasFolders = folder.listFiles();

        for (File file : listOfRutasFolders) {
            File import_folder;
            File[] listOfImportedLogs;
            import_folder = new File(file.getPath() + "/logs_Reports/" + file.getName() + "/");
            listOfImportedLogs = import_folder.listFiles();
            for (File file2 : listOfImportedLogs) {
                if (file2.isFile()) {
                    String rep_name = file2.getName();
                    System.out.println(rep_name + " " + new Date(file2.lastModified()) + " " + TimeUnit.MINUTES.convert((new Date().getTime() - file2.lastModified()), TimeUnit.MILLISECONDS));
                    if (TimeUnit.MINUTES.convert((new Date().getTime() - file2.lastModified()), TimeUnit.MILLISECONDS) > 2) {
                        System.out.println("Moviendo rep procesado:" + rep_name);
                        InputStream is_reporte = null;
                        XSSFWorkbook wb_reporte = null;
                        try {
                            is_reporte = new FileInputStream(file2);
                            wb_reporte = new XSSFWorkbook(is_reporte);
                            Sheet sh_resumen = wb_reporte.getSheet("Hoja2");
                            boolean is_not_firstrow = false;
                            for (Row rw_resumen : sh_resumen) {
                                if (is_not_firstrow) {
                                    String log_name_largo = rw_resumen.getCell(1).getStringCellValue().trim() + ".trp";
                                    double min_recorridos = rw_resumen.getCell(2).getNumericCellValue();
                                    Date fecha_ini = rw_resumen.getCell(5).getDateCellValue();
                                    Date fecha_fin = rw_resumen.getCell(6).getDateCellValue();

                                    ArrayList<String> logname_parsed = new ArrayList(Arrays.asList((log_name_largo.trim()).split("_")));
                                    String log_name_corto = logname_parsed.get(2).trim();

                                    if (al_logfiles.indexOf(new Logfile(log_name_corto)) != -1) {
                                        Logfile logfile = al_logfiles.get(al_logfiles.indexOf(new Logfile(log_name_corto)));
                                        if (!logfile.isprocesado) {
                                            if (logfile.isimportado) {
                                                logfile.min_recorridos = min_recorridos;
                                                logfile.fecha_ini = fecha_ini;
                                                logfile.fecha_fin = fecha_fin;

                                                Sheet sh_eventos = wb_reporte.getSheet("Hoja1");
                                                boolean is_not_firstrow2 = false;
                                                ArrayList<String[]> eventos = new ArrayList();
                                                for (Row rw_eventos : sh_eventos) {
                                                    if (is_not_firstrow2) {
                                                        String ev_fecha = rw_eventos.getCell(0).getStringCellValue();
                                                        Date fecha_evento = null;
                                                        try {
                                                            fecha_evento = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").parse(ev_fecha);
                                                        } catch (ParseException ex) {
                                                            System.out.println("Error parseo: " + ex.getMessage());
                                                            continue;
                                                        }
                                                        if (fecha_evento.compareTo(logfile.fecha_ini) >= 0 && fecha_evento.compareTo(logfile.fecha_fin) <= 0) {
                                                            if (rw_eventos.getCell(1) != null && rw_eventos.getCell(2) != null) {
                                                                String ev_lat = Double.toString(rw_eventos.getCell(1).getNumericCellValue());
                                                                String ev_lon = Double.toString(rw_eventos.getCell(2).getNumericCellValue());
                                                                for (int i_evento = 3; i_evento <= 8; i_evento++) {
                                                                    String st_evento = rw_eventos.getCell(i_evento).getStringCellValue().trim();
                                                                    if (st_evento.compareTo("") != 0) {
                                                                        String[] fila_evento = {ev_fecha, ev_lat, ev_lon, st_evento};
                                                                        eventos.add(fila_evento);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    is_not_firstrow2 = true;
                                                }
                                                logfile.eventos = eventos;
                                                logfile.reporte = rep_name;
                                                logfile.isprocesado = true;
                                                logfile.fechaprocesado = new Date();
                                                logfile.vecesprocesado = 1;
                                            } else {
                                                System.out.println(log_name_corto + " procesado no esta importado!!!");
                                            }
                                        } else {
                                            logfile.vecesprocesado++;
                                            System.out.println(log_name_corto + " ya esta procesado!!!");
                                        }
                                    } else {
                                        System.out.println(log_name_corto + " no esta en lista de logfiles!!!");
                                    }
                                }
                                is_not_firstrow = true;
                            }
                        } catch (IOException e) {
                            System.out.println("Error excel: " + e.getMessage());
                        } finally {
                            try {
                                wb_reporte.close();
                                is_reporte.close();
                                System.out.println("Archivo cerrado");
                            } catch (IOException ex) {
                                System.out.println("Error cerrando wb: " + ex.getMessage());
                            }
                        }

                        try {
                            Thread.sleep(2000);
                        } catch (Exception e) {
                        }

                        try {
                            Path temp = Files.move(Paths.get(file.getPath() + "/logs_Reports/" + file.getName() + "/" + file2.getName()), Paths.get(file.getPath() + "/reps_Finished/" + file2.getName()));
                        } catch (IOException ex) {
                            System.out.println("Error moviendo archivo procesado: " + ex.getMessage());
                        }

                    }
                }
            }
        }
    }

    private void check_delayed_files() {
        long f_delay = 0;
        for (Ruta ruta : al_rutas) {
            for (String drive : ruta.drives.keySet()) {
                for (String drivelog : ruta.drives.get(drive)) {
                    if (al_logfiles.indexOf(new Logfile(drivelog)) != -1) {
                        Logfile f_logfile = al_logfiles.get(al_logfiles.indexOf(new Logfile(drivelog)));
                        if (f_logfile.isprocesado == false && f_logfile.isimportado == true) {
                            f_delay = TimeUnit.MINUTES.convert((new Date().getTime() - f_logfile.fechaimportado.getTime()), TimeUnit.MILLISECONDS);
                            if (f_delay > delay_procesado) {
                                System.out.println(drivelog + " tiene delay para ser procesado: " + f_delay);
                            }
                        } else if (f_logfile.isimportado == false && f_logfile.issubido == true) {
                            f_delay = TimeUnit.MINUTES.convert((new Date().getTime() - f_logfile.fechasubido.getTime()), TimeUnit.MILLISECONDS);
                            if (f_delay > delay_importado) {
                                System.out.println(drivelog + " tiene delay para ser importado: " + f_delay);
                            }
                        } else if (f_logfile.issubido == false && f_logfile.isxsubir == true) {
                            f_delay = TimeUnit.MINUTES.convert((new Date().getTime() - f_logfile.fechaxsubir.getTime()), TimeUnit.MILLISECONDS);
                            if (f_delay > delay_subido) {
                                System.out.println(drivelog + " tiene delay para ser subido: " + f_delay);
                            }
                        }
                    } else {
                        System.out.println(drivelog + " en rutas no esta en logfiles!!");
                    }
                }
            }
        }
    }

    private void check_rutas_finished() {
        for (Ruta ruta : al_rutas) {
            ArrayList<String> drivesxborrar = new ArrayList();
            for (String drive : ruta.drives.keySet()) {
                boolean is_not_finished = false;
                for (String logfile : ruta.drives.get(drive)) {
                    if (al_logfiles.indexOf(new Logfile(logfile)) != -1) {
                        Logfile f_logfile = al_logfiles.get(al_logfiles.indexOf(new Logfile(logfile)));
                        if (f_logfile.isprocesado == false) {
                            is_not_finished = true;
                        }
                    } else {
                        System.out.println(logfile + " en rutas no esta en logfiles!!");
                        is_not_finished = true;
                    }
                }
                if (!is_not_finished) {
                    System.out.println("Ruta " + ruta.ruta_id + " drive " + drive + " finalizado!!");
                    drivesxborrar.add(drive);
                }
            }
            for (String drivexborrar : drivesxborrar) {
                ArrayList<Date> al_fecha_ini = new ArrayList();
                ArrayList<Date> al_fecha_fin = new ArrayList();
                String telegram = "Resultado drive " + rutas_names.get(ruta.ruta_id);
                int callini = 0;
                int block = 0;
                int csfb_block = 0;
                int drop = 0;
                int callrest = 0;
                String logfiles = "";
                String reportes = "";
                boolean is_not_first = false;
                boolean is_not_first2 = false;
                ArrayList<String[]> eventos_sql = new ArrayList();

                ArrayList<String> logsxborrar = new ArrayList();
                for (String drivelog : ruta.drives.get(drivexborrar)) {
                    logsxborrar.add(drivelog);
                    Logfile logfile = al_logfiles.get(al_logfiles.indexOf(new Logfile(drivelog)));
                    al_fecha_ini.add(logfile.fecha_ini);
                    al_fecha_fin.add(logfile.fecha_fin);
                    if (!logfiles.contains(logfile.logname)) {
                        logfiles += (is_not_first ? " " : "") + logfile.logname;
                        is_not_first = true;
                    }
                    if (!reportes.contains(logfile.reporte)) {
                        reportes += (is_not_first2 ? " " : "") + logfile.reporte;
                        is_not_first2 = true;
                    }

                    for (String[] al_evento : logfile.eventos) {
                        String evento_name = al_evento[3];
                        if (evento_name.compareTo("Call Initiation") == 0) {
                            callini++;
                        }
                        if (evento_name.compareTo("Call Dropped") == 0) {
                            drop++;
                        }
                        if (evento_name.compareTo("Call Re-established") == 0) {
                            callrest++;
                        }
                        if (evento_name.compareTo("Call Blocked") == 0) {
                            block++;
                        }
                        if (evento_name.compareTo("Call Blocked CSFB") == 0) {
                            csfb_block++;
                        }
                        eventos_sql.add(al_evento);
                    }
                }
                telegram += "\nIni: " + Collections.min(al_fecha_ini) + " - Fin: " + Collections.max(al_fecha_fin);
                telegram += "\nLlamadas: " + callini;
                telegram += "\nCaidas: " + drop;
                telegram += "\nRestablecidas: " + callrest;
                telegram += "\nBloqueadas: " + block;
                telegram += "\nBloqueadas CSFB: " + csfb_block;
                telegram += "\nLogs: " + logfiles;
                telegram += "\nReportes: " + reportes;
                ruta.drives.remove(drivexborrar);
                for (String logxborrar : logsxborrar) {
                    al_logfiles.remove((new Logfile(logxborrar)));
                }
                load_logsxsubir(logfiles, reportes, callini, Collections.min(al_fecha_ini), Collections.max(al_fecha_fin), ruta.ruta_id);
                load_eventos(eventos_sql, reportes);
//                tcliente.send_telegram("12", telegram);
                System.out.println(telegram);
            }
        }
    }

    private void load_logsxsubir(String f_logfiles, String f_reportes, int f_callini, Date f_fecha_ini, Date f_fecha_fin, int f_ruta_id) {
        Connection simdb_con = null;
        PreparedStatement simdb_pst = null;
        String simdb_url = "jdbc:mysql://127.0.0.1:3306/";
        String simdb_user = "root";
        String simdb_pass = "enero2012";
        String simdb_query = "";
        SimpleDateFormat dformat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

        try {
            simdb_con = DriverManager.getConnection(simdb_url, simdb_user, simdb_pass);
            simdb_query = "INSERT INTO qrutas.drives (logfiles, reportes, llamadas, fechaini, fechafin, id_ruta) VALUES ('"
                    + f_logfiles + "','" + f_reportes
                    + "'," + f_callini + ",'" + dformat.format(f_fecha_ini) + "','" + dformat.format(f_fecha_fin) + "'," + f_ruta_id + ")";
            simdb_pst = simdb_con.prepareStatement(simdb_query);
            simdb_pst.executeUpdate();
        } catch (SQLException ex) {
            System.out.println(ex.getMessage());
            ex.printStackTrace();
        } finally {
            try {
                if (simdb_pst != null) {
                    simdb_pst.close();
                }
                if (simdb_con != null) {
                    simdb_con.close();
                }
            } catch (SQLException ex) {
                System.out.println(ex.getMessage());
                ex.printStackTrace();
            }
        }
    }

    private void load_eventos(ArrayList<String[]> f_eventos_sql, String f_reportes) {
        Connection simdb_con = null;
        PreparedStatement simdb_pst = null;
        ResultSet simdb_rs = null;
        String simdb_url = "jdbc:mysql://127.0.0.1:3306/";
        String simdb_user = "root";
        String simdb_pass = "enero2012";
        String simdb_query = "";
        SimpleDateFormat dformat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String drive_id = "";
        Map<String, Integer> eventotipos = new HashMap();
        eventotipos.put("Call Dropped", 1);
        eventotipos.put("Call Blocked", 2);
        eventotipos.put("Call Re-established", 3);
        eventotipos.put("Call Blocked CSFB", 4);

        try {
            simdb_con = DriverManager.getConnection(simdb_url, simdb_user, simdb_pass);
            simdb_query = "SELECT id FROM qrutas.drives where reportes = '" + f_reportes + "' limit 1";
            simdb_pst = simdb_con.prepareStatement(simdb_query);
            simdb_rs = simdb_pst.executeQuery();
            while (simdb_rs.next()) {
                drive_id = simdb_rs.getString("id");
            }
            for (String[] al_evento : f_eventos_sql) {
                if (al_evento[3].contains("Call Initiation") || al_evento[3].contains("End of file")) {
                    continue;
                }
                Date fecha_evento = null;
                try {
                    fecha_evento = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").parse(al_evento[0]);
                } catch (ParseException ex) {
                    System.out.println("Error parseo: " + ex.getMessage());
                    continue;
                }
                simdb_query = "INSERT INTO qrutas.eventos (id_eventotipo, latitud, longitud, fecha, id_drive) VALUES ("
                        + eventotipos.get(al_evento[3]) + "," + al_evento[1] + "," + al_evento[2] + ",'" + dformat.format(fecha_evento)
                        + "'," + drive_id + ")";
                simdb_pst = simdb_con.prepareStatement(simdb_query);
                simdb_pst.executeUpdate();
            }
        } catch (SQLException ex) {
            System.out.println(ex.getMessage());
            ex.printStackTrace();
        } finally {
            try {
                if (simdb_pst != null) {
                    simdb_pst.close();
                }
                if (simdb_con != null) {
                    simdb_con.close();
                }
            } catch (SQLException ex) {
                System.out.println(ex.getMessage());
                ex.printStackTrace();
            }
        }
    }

    private Map<Integer, String> carga_lista_rutas() {
        Connection con_uio = null;
        PreparedStatement pst_uio = null;
        ResultSet rs_db_uio = null;
        String url_uio = "jdbc:mysql://" + s_servidor + ":3306/";
        String user = "root";
        String password = "enero2012";
        String db_query = "select * from qrutas.rutas";
        Map<Integer, String> url_list_al = new HashMap();

        try {
            con_uio = DriverManager.getConnection(url_uio, user, password);
            pst_uio = con_uio.prepareStatement(db_query);
            rs_db_uio = pst_uio.executeQuery();
            while (rs_db_uio.next()) {
                url_list_al.put(rs_db_uio.getInt("id"), rs_db_uio.getString("ruta"));
            }
        } catch (SQLException ex) {
            System.out.println(ex.getMessage());
            ex.printStackTrace();
        } finally {
            try {
                if (rs_db_uio != null) {
                    rs_db_uio.close();
                }
                if (pst_uio != null) {
                    pst_uio.close();
                }
                if (con_uio != null) {
                    con_uio.close();
                }
            } catch (SQLException ex) {
                System.out.println(ex.getMessage());
                ex.printStackTrace();
            }
        }
        return url_list_al;
    }

    class Ruta implements Comparable<Ruta> {

        public Integer ruta_id;
        public Map<String, ArrayList<String>> drives;

        public Ruta(int f_ruta_id) {
            ruta_id = f_ruta_id;
            drives = new TreeMap();
        }

        @Override
        public int compareTo(Ruta other) {
            return ruta_id.compareTo(other.ruta_id);
        }

        @Override
        public boolean equals(Object obj) {
            if (obj instanceof Ruta) {
                Ruta eruta = (Ruta) obj;
                return this.ruta_id.compareTo(eruta.ruta_id) == 0;
            } else {
                throw new IllegalArgumentException("Ruta expected");
            }
        }
    }

    class Logfile implements Comparable<Logfile> {

        public String logname;
        public boolean isxsubir;
        public Date fechaxsubir;
        public int vecesxsubir;
        public boolean issubido;
        public Date fechasubido;
        public int vecessubido;
        public boolean isimportado;
        public Date fechaimportado;
        public int vecesimportado;
        public boolean isprocesado;
        public Date fechaprocesado;
        public int vecesprocesado;
        public double min_recorridos;
        public Date fecha_ini;
        public Date fecha_fin;
        public ArrayList<String[]> eventos;
        public String reporte;

        public Logfile(String f_logname) {
            logname = f_logname;
            isxsubir = true;
            fechaxsubir = new Date();
            vecesxsubir = 1;
            issubido = false;
            fechasubido = null;
            vecessubido = 0;
            isimportado = false;
            fechaimportado = null;
            vecesimportado = 0;
            isprocesado = false;
            fechaprocesado = null;
            vecesprocesado = 0;
            min_recorridos = 0;
            fecha_ini = null;
            fecha_fin = null;
            eventos = new ArrayList();
            reporte = "";
        }

        @Override
        public int compareTo(Logfile other) {
            return logname.compareTo(other.logname);
        }

        @Override
        public boolean equals(Object obj) {
            if (obj instanceof Logfile) {
                Logfile eruta = (Logfile) obj;
                return this.logname.compareTo(eruta.logname) == 0;
            } else {
                throw new IllegalArgumentException("Ruta expected");
            }
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jB_run;
    private javax.swing.JButton jB_save;
    private javax.swing.JButton jB_status;
    private javax.swing.JCheckBox jCB_loadvariables;
    // End of variables declaration//GEN-END:variables
}
